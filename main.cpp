#include <iostream>
<<<<<<< Updated upstream
#include <cstdlib>
#include <ctime>
#include <vector>
#include <algorithm>

using namespace std;

string Mons[10] = {"Floraburn", "Shockfin", "Frostmoth", "Shadowmind", "Voltbrawler", "Terrafey", "Ironcladore", "Spectrake", "Toxiwarrior", "Metatuff"};

int* picker(int seed, vector<int>& picked)
{
    srand(seed);
    int team[3];

    for (int i = 0; i < 3; i++) {
        int Mon;
        do {
            Mon = rand() % 10;
        } while (find(picked.begin(), picked.end(), Mon) != picked.end());

        picked.push_back(Mon);
        team[i] = Mon;
    }

    int* result = new int[3];
    for (int i = 0; i < 3; i++) {
        result[i] = team[i];
    }

    return result;
=======
#include <string>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

// Define the monster names
std::vector<std::string> Mons = {"Floraburn", "Shockfin", "Frostmoth", "Shadowmind", "Voltbrawler", "Terrafey", "Ironcladore", "Spectrake", "Toxiwarrior", "Metatuff"};

// Function to pick monsters for a team
std::vector<int> picker(std::vector<int> otherTeam)
{
    // Shuffle the monster indices
    std::vector<int> indices(Mons.size());
    std::iota(indices.begin(), indices.end(), 0);
    std::shuffle(indices.begin(), indices.end(), std::default_random_engine(std::chrono::system_clock::now().time_since_epoch().count()));

    // Pick the first three unique monsters that are not in the other team
    std::vector<int> team;
    for (int i = 0; i < indices.size() && team.size() < 3; i++) {
        if (std::find(otherTeam.begin(), otherTeam.end(), indices[i]) == otherTeam.end()) {
            team.push_back(indices[i]);
        }
    }

    return team;
>>>>>>> Stashed changes
}

int main()
{
<<<<<<< Updated upstream
    vector<int> picked;
    int *team1;
    int *team2;

    srand(time(0));
    int seed1 = rand();
    team1 = picker(seed1, picked);

    int seed2;
    do {
        seed2 = rand();
    } while (seed2 == seed1);

    team2 = picker(seed2, picked);

    string roster1[3] = {Mons[team1[0]], Mons[team1[1]], Mons[team1[2]]};
    string roster2[3] = {Mons[team2[0]], Mons[team2[1]], Mons[team2[2]]};

    cout << "Team 1:\n";
    for (int i = 0; i < 3; i++) {
        cout << roster1[i] << "\n";
    }

    cout << "Team 2:\n";
    for (int i = 0; i < 3; i++) {
        cout << roster2[i] << "\n";
    }

    // Deallocate memory for result arrays
    delete[] team1;
    delete[] team2;

    return 0;
}

/*
Fixed using ChatGPT
The issue is with the usage of static when returning the result. In this case, the static keyword
is causing the result array to retain its state between calls to the picker function, which is why 
you're seeing the same teams in both team1 and team2.

You can remove the static keyword from the result array to ensure that each call to picker generates a unique set of teams.

With this change, the teams generated by each call to the picker function should be unique. 
Also, make sure to deallocate memory for the team1 and team2 arrays at the end of the main function to avoid memory leaks.

Then:
I apologize for the previous issues. It seems there was an issue with the handling of the picked vector between calls to the picker function, 
and it resulted in duplicate Pokémon in the teams. 
To address this and ensure that both teams are unique, here's an updated version of your code:

This updated code should ensure that both teams are unique by correctly managing the picked vector between calls to the picker function. 
It uses a do-while loop to select Pokémon and check for duplicates in the picked vector. 
The code also deallocates memory for the result arrays at the end of the main function.
*/
=======
    // Pick monsters for each team
    std::vector<int> team1 = picker({});
    std::vector<int> team2 = picker(team1);

    // Print the selected monsters for each team
    std::cout << "Team 1:\n";
    for (int i = 0; i < 3; i++) {
        std::cout << Mons[team1[i]] << "\n";
    }
    std::cout << "Team 2:\n";
    for (int i = 0; i < 3; i++) {
        std::cout << Mons[team2[i]] << "\n";
    }

    return 0;
}

/* Fixed with the assistance of GitHub CoPilot

According to GitHub CoPilot:
GitHub Copilot: The reason why the first script didn't work properly is that it didn't include 
the `std` namespace for the `string` type. In C++, the `string` type is defined in the `std` namespace, 
so you need to either use the fully qualified name `std::string` or include the `using namespace std;` 
directive to bring the `std` namespace into scope.

In the second script, the `using namespace std;` directive is included, so the `string` type can be used 
without the `std::` prefix. Additionally, the `string` type is used to define the `Mons` array, 
which is more convenient than using a C-style array of `char*` pointers.

Another difference between the two scripts is that the second script uses a C-style array of `int` pointers
to represent the picked monsters, while the first script uses a `std::vector<int>` to represent the 
picked monsters. The `std::vector` class provides more convenient and safer memory management than 
C-style arrays, and allows you to easily resize the array if needed.
*/

>>>>>>> Stashed changes
